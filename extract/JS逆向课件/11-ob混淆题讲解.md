# 11 令人抓狂的 JavaScript 混淆技术

## 11.1 JS 简介

**JavaScript 压缩、混淆和加密技术**

对于网页来说，其逻辑是依赖于`JavaScript`来实现的，`JavaScript` 有如下特点：

- `JavaScript` 代码运行于客户端，也就是它必须要在用户浏览器端加载并运行。
- `JavaScript` 代码是公开透明的，也就是说浏览器可以直接获取到正在运行的 `JavaScript` 的源码。

**压缩、混淆、加密技术简述如下**

- 代码压缩：即去除`JavaScript` 代码中的不必要的空格、换行等内容，使源码都压缩为几行内容，降低代码可读性，当然同时也能提高网站的加载速度。

- 代码混淆：使用变量替换、字符串阵列化、控制流平坦化、多态变异、僵尸函数、调试保护等手段，使代码变得难以阅读和分析，达到最终保护的目的。但这不影响代码原有功能。是理想、实用的`JavaScript`保护方案

- 代码加密：可以通过某种手段将 JavaScript 代码进行加密，转成人无法阅读或者解析的代码，如将代码完全抽象化加密，如 eval 加密。另外还有更强大的加密技术，可以直接将 `JavaScript` 代码用 C/C++ 实现，`JavaScript` 调用其编译后形成的文件来执行相应的功能，如`Emscripten` 还有 `WebAssembly`。

## 11.2 OB 混淆

`OB` 混淆全称 Obfuscator，Obfuscator 其实就是混淆的意思，官网：[https://obfuscator.io/](https://links.jianshu.com/go?to=https%3A%2F%2Fobfuscator.io%2F) ，其作者是一位叫 Timofey Kachalov 的俄罗斯`JavaScript`开发工程师，早在 2016 年就发布了第一个版本。

### 11.2.1 OB 混淆具有以下特征

1、一般由一个大数组或者含有大数组的函数、一个自执行函数、解密函数和加密后的函数四部分组成；

2、函数名和变量名通常以 `_0x` 或者 `0x` 开头，后接 1~6 位数字或字母组合；

3、自执行函数，进行移位操作，有明显的 push、shift 关键字；

例如在上面的例子中，`_0x3f26()` 方法就定义了一个大数组，自执行函数里有 push、shift 关键字，主要是对大数组进行移位操作，`_0x1fe9()` 就是解密函数，`hi()` 就是加密后的函数。

![image-20220822141218145](images\image-20220822141218145.png)

### 11.2.2 OB 混淆介绍

​ JavaScript 混淆完全是在 JavaScript 上面进行的处理，它的目的就是使得 JavaScript 变得难以阅读和分析，大大降低代码可读性，是一种很实用的 JavaScript 保护方案。

**JavaScript 混淆技术主要有以下几种：**

- 变量混淆
  将带有含意的变量名、方法名、常量名随机变为无意义的类乱码字符串，降低代码可读性，如转成单个字符或十六进制字符串。

- 字符串混淆
  将字符串阵列化集中放置、并可进行 MD5 或 Base64 加密存储，使代码中不出现明文字符串，这样可以避免使用全局搜索字符串的方式定位到入口点。

- 属性加密
  针对 JavaScript 对象的属性进行加密转化，隐藏代码之间的调用关系。

- 控制流平坦化
  打乱函数原有代码执行流程及函数调用关系，使代码逻变得混乱无序。

- 僵尸代码
  随机在代码中插入无用的僵尸代码、僵尸函数，进一步使代码混乱。

- 调试保护
  基于调试器特性，对当前运行环境进行检验，加入一些强制调试 debugger 语句，使其在调试模式下难以顺利执行 JavaScript 代码。

- 多态变异
  使 JavaScript 代码每次被调用时，将代码自身即立刻自动发生变异，变化为与之前完全不同的代码，即功能完全不变，只是代码形式变异，以此杜绝代码被动态分析调试。

- 锁定域名
  使 JavaScript 代码只能在指定域名下执行。

- 反格式化
  如果对 JavaScript 代码进行格式化，则无法执行，导致浏览器假死。

- 特殊编码
  将 JavaScript 完全编码为人不可读的代码，如表情符号、特殊表示内容等等。

总之，以上方案都是 JavaScript 混淆的实现方式，可以在不同程度上保护 JavaScript 代码。

### 11.2.3 OB 混淆 JS

新建一个文件夹，比如`feifei`，随后进入该文件夹，初始化工作空间

```js
npm init
```

提示我们输入一些信息，创建一个 package.json 文件，这就完成了项目初始化了。

接下来我们来安装 `javascript-obfuscator`这个库：

```js
npm install javascript-obfuscator -g
```

安装完成后，`javascript-obfuscator`就是一个独立的可执行命令了。

#### 11.2.3.1 **代码压缩**

这里`javascript-obfuscator`也提供了代码压缩的功能，使用其参数 `compact`即可完成`JavaScript` 代码的压缩，输出为一行内容。默认是 true，如果定义为 false，则混淆后的代码会分行显示。

```js
var code = `
let x = '1' + 1
console.log('x', x)
`;

const options = {
  compact: true, // 代码压缩配置
};

const obfuscator = require("javascript-obfuscator");

function obfuscate(code, options) {
  return obfuscator.obfuscate(code, options).getObfuscatedCode();
}

console.log(obfuscate(code, options));
```

#### 11.2.3.2 **变量名混淆**

变量名混淆可以通过配置`identifierNamesGenerator` 参数实现，我们通过这个参数可以控制变量名混淆的方式，如`hexadecimal`则会替换为 16 进制形式的字符串，在这里我们可以设定如下值：

- `hexadecimal`：将变量名替换为 16 进制形式的字符串，如 `0xabc123`。
- `mangled`：将变量名替换为普通的简写字符，如 a、b、c 等。
  该参数默认为`hexadecimal`。

我们将该参数修改为 `mangled` 来试一下：

```js
const code = `
let hello = '1' + 1
console.log('hello', hello)
`;
const options = {
  compact: true,
  identifierNamesGenerator: "mangled",
};
```

#### 11.2.3.3 字符串混淆

字符串混淆，即将一个字符串声明放到一个数组里面，使之无法被直接搜索到。我们可以通过控制 `stringArray` 参数来控制，默认为 true。

```js
const code = `
var a = 'hello world'
`;
const options = {
  compact: false,
  unicodeEscapeSequence: true, //对字符串进行 Unicode 转码
};
```

## 11.3 数据加密

### 11.3.1 逆向目标

- 首页：https://bz.zzzmh.cn/index
- API：https://api.zzzmh.cn/bz/v3/getData
- 目标：result: `ak+9VCsq4dEdB+UdVfGo8kh5JDEbMHGTCmF/`

### 11.3.2 逆向分析

- 解除无限 debugger

  ```javascript
  Function.prototype.__constructor_back = Function.prototype.constructor;
  Function.prototype.constructor = function () {
    if (arguments && typeof arguments[0] === "string") {
      if ("debugger" === arguments[0]) {
        return;
      }
    }
    return Function.prototype.__constructor_back.apply(this, arguments);
  };
  ```

- 下`xhr`断点调试，跟栈调试

![image-20220822164135259](images\image-20220822164135259.png)

- 解密方法

  ```javascript
  _0x3042ee["a"]["decipher"](_0x45e4b9["data"][_0x4a9a("0x67", "uMwG")]);
  ```

#### 11.4.2.1 找到执行解密函数的位置

![image-20220823143310893](images\image-20220823143310893.png)

注:可以看到这里是使用相关函数对该代码进行了解密操作，找对对应的函数模拟相关操作即可

### 11.4.3 逆向结果

- 替换混淆的关键字，输出对应的结果。

```javascript
见课件代码;
```

**数据结果展示**

![image-20220823144953793](images\image-20220823144953793.png)

## 11.4 octet-stream

简介：**octet**-**stream 指任意类型的二进制流数据。**

### 11.4.1 逆向目标

- 地址：http://www.spolicy.com/
- 接口：http://www.spolicy.com/info_api/policyType/showPolicyType
- 目标：参数加密

### 11.4.2 逆向分析

需要先 Hook 掉 debugger；

```javascript
var _constructor = constructor;
Function.prototype.constructor = function (s) {
  if (s == "debugger") {
    console.log(s);
    return null;
  }
  return _constructor(s);
};
```

下 xhr 断点,开始分析，往下执行可以发现数据接收有一个响应拦截器

![image-20221127160137806](images\image-20221127160137806.png)

可以从这个位置找请求拦截器进行分析，定位以后，先从请求拦截器里面分析代码，看明文到密文的切换经过了什么操作。

![image-20221127160313986](images\image-20221127160313986.png)

此图为明文数据

![image-20221127160431906](images\image-20221127160431906.png)

往下看代码和业务逻辑，27233 是数据的加密位置，他是从明文到密文的转换

![image-20221127160758958](images\image-20221127160758958.png)

跟到内部的核心代码查看，数据是进入这个方法里面加密的

![image-20221127160928964](images\image-20221127160928964.png)
